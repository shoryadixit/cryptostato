{"ast":null,"code":"// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function (nodes) {\n  var idx = nodes.length,\n      node,\n      ancestor,\n      replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = ancestor.parent;\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n}; // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n\n\nvar POSITION = {\n  DISCONNECTED: 1,\n  PRECEDING: 2,\n  FOLLOWING: 4,\n  CONTAINS: 8,\n  CONTAINED_BY: 16\n}; // Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\n\nvar comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n  var current, sharedParent, siblings, aSibling, bSibling, idx;\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  current = nodeA;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = nodeB;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  idx = 0;\n\n  while (aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return POSITION.DISCONNECTED;\n  }\n\n  sharedParent = aParents[idx - 1];\n  siblings = sharedParent.children;\n  aSibling = aParents[idx];\n  bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n    }\n\n    return POSITION.FOLLOWING;\n  } else {\n    if (sharedParent === nodeA) {\n      return POSITION.PRECEDING | POSITION.CONTAINS;\n    }\n\n    return POSITION.PRECEDING;\n  }\n}; // Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\n\n\nexports.uniqueSort = function (nodes) {\n  var idx = nodes.length,\n      node,\n      position;\n  nodes = nodes.slice();\n\n  while (--idx > -1) {\n    node = nodes[idx];\n    position = nodes.indexOf(node);\n\n    if (position > -1 && position < idx) {\n      nodes.splice(idx, 1);\n    }\n  }\n\n  nodes.sort(function (a, b) {\n    var relative = comparePos(a, b);\n\n    if (relative & POSITION.PRECEDING) {\n      return -1;\n    } else if (relative & POSITION.FOLLOWING) {\n      return 1;\n    }\n\n    return 0;\n  });\n  return nodes;\n};","map":{"version":3,"names":["exports","removeSubsets","nodes","idx","length","node","ancestor","replace","indexOf","splice","parent","POSITION","DISCONNECTED","PRECEDING","FOLLOWING","CONTAINS","CONTAINED_BY","comparePos","compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","sharedParent","siblings","aSibling","bSibling","unshift","children","uniqueSort","position","slice","sort","a","b","relative"],"sources":["/media/shorya/Local Disk/cryptoStato/node_modules/domutils/lib/helpers.js"],"sourcesContent":["// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}